{
	"problem_statement": "Replies without a delimiter\nWhen Outlook replies to a reply from Mail.app (for example), there may not be a delimiter between the reply and the From/To/Subject headers from the last reply. For instance:\n\n```\nAnd another reply!\n\nFrom: Dan Watson [mailto:user@host.com]\nSent: Monday, November 26, 2012 10:48 AM\nTo: Watson, Dan\nSubject: Re: New Issue\n\nA reply\n\n--\nSent from my iPhone\n\nOn Nov 26, 2012, at 10:27 AM, \"Watson, Dan\" <user@host2.com> wrote:\nThis is a message.\nWith a second line.\n```\n\nI would expect the last reply to be just \"And another reply!\", but instead it includes the previous headers plus the \"A reply\" line. I don't really have a good solution (aside from maybe checking for a \"From\" header line), and don't fully understand the code, just thought I'd mention it.\n\n",
	"patch": "diff --git a/email_reply_parser/__init__.py b/email_reply_parser/__init__.py\nindex 427113f..16191fe 100644\n--- a/email_reply_parser/__init__.py\n+++ b/email_reply_parser/__init__.py\n@@ -40,6 +40,7 @@ class EmailMessage(object):\n     QUOTE_HDR_REGEX = r'^:etorw.*nO'\n     MULTI_QUOTE_HDR_REGEX = r'(?!On.*On\\s.+?wrote:)(On\\s(.+?)wrote:)'\n     QUOTED_REGEX = r'(>+)'\n+    HEADER_REGEX = r'^(From|Sent|To|Subject): .+'\n \n     def __init__(self, text):\n         self.fragments = []\n@@ -91,25 +92,21 @@ def _scan_line(self, line):\n             line - a row of text from an email message\n         \"\"\"\n \n-        line.strip('\\n')\n-\n-        if re.match(self.SIG_REGEX, line):\n-            line.lstrip()\n-\n-        is_quoted = re.match(self.QUOTED_REGEX, line) != None\n+        is_quoted = re.match(self.QUOTED_REGEX, line) is not None\n+        is_header = re.match(self.HEADER_REGEX, line) is not None\n \n         if self.fragment and len(line.strip()) == 0:\n             if re.match(self.SIG_REGEX, self.fragment.lines[-1]):\n                 self.fragment.signature = True\n                 self._finish_fragment()\n \n-        if self.fragment and ((self.fragment.quoted == is_quoted)\n+        if self.fragment and (((self.fragment.headers == is_header) and (self.fragment.quoted == is_quoted))\n             or (self.fragment.quoted and (self.quote_header(line) or len(line.strip()) == 0))):\n \n             self.fragment.lines.append(line)\n         else:\n             self._finish_fragment()\n-            self.fragment = Fragment(is_quoted, line)\n+            self.fragment = Fragment(is_quoted, line, headers=is_header)\n \n     def quote_header(self, line):\n         \"\"\" Determines whether line is part of a quoted area\n@@ -126,8 +123,15 @@ def _finish_fragment(self):\n \n         if self.fragment:\n             self.fragment.finish()\n+            if self.fragment.headers:\n+                # Regardless of what's been seen to this point, if we encounter a headers fragment,\n+                # all the previous fragments should be marked hidden and found_visible set to False.\n+                self.found_visible = False\n+                for f in self.fragments:\n+                    f.hidden = True\n             if not self.found_visible:\n                 if self.fragment.quoted \\\n+                or self.fragment.headers \\\n                 or self.fragment.signature \\\n                 or (len(self.fragment.content.strip()) == 0):\n \n@@ -143,8 +147,9 @@ class Fragment(object):\n         an Email Message, labeling each part.\n     \"\"\"\n \n-    def __init__(self, quoted, first_line):\n+    def __init__(self, quoted, first_line, headers=False):\n         self.signature = False\n+        self.headers = headers\n         self.hidden = False\n         self.quoted = quoted\n         self._content = None\n",
	"s3_repo_url": "s3://codeatcommits/zapier-email-reply-parser-76e9481c1a183048d0a1af0148d9f0cbd3556753.zip"
}